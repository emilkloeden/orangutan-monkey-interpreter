let loops = use("../stdlib/loops.üêµ")
let token = use("token.üêµ");
let lexer = use("lexer.üêµ");
let ast = use("ast.üêµ");

let while = loops.while;
let TokenType = token.TokenType;
let newLexer = lexer.newLexer

let Precedence = {
    "LOWEST": 0,
    "OR": 2,
    "AND": 3,
    "ASSIGN": 4,
    "EQUALS": 5,
    "LESSGREATER": 6,
    "SUM": 7,
    "PRODUCT": 8,
    "MODULO": 9,
    "PREFIX": 10,
    "CALL": 11,
    "INDEX": 12,
}

let precedences = {
    TokenType["EQ"]: Precedence["EQUALS"],
    TokenType["NOT_EQ"]: Precedence["EQUALS"],
    TokenType["LT"]: Precedence["LESSGREATER"],
    TokenType["LTE"]: Precedence["LESSGREATER"],
    TokenType["GT"]: Precedence["LESSGREATER"],
    TokenType["GTE"]: Precedence["LESSGREATER"],
    TokenType["PLUS"]: Precedence["SUM"],
    TokenType["MINUS"]: Precedence["SUM"],
    TokenType["SLASH"]: Precedence["PRODUCT"],
    TokenType["ASTERISK"]: Precedence["PRODUCT"],
    TokenType["MODULO"]: Precedence["MODULO"],
    TokenType["AND"]: Precedence["AND"],
    TokenType["OR"]: Precedence["OR"],
    TokenType["LPAREN"]: Precedence["CALL"],
    TokenType["LBRACKET"]: Precedence["INDEX"],
    TokenType["PERIOD"]: Precedence["INDEX"],
    TokenType["ASSIGN"]: Precedence["ASSIGN"],
}

let newParser = fn(l) {
    let lexer = l;
    let errors = [];
    let currentToken = lexer.nextToken();
    let peekToken = lexer.nextToken();

    let prefixParseFns = fn () {
        {
            TokenType["IDENT"]: parseIdentifier,
            TokenType["INT"]: parseIntegerLiteral,
            TokenType["BANG"]: parsePrefixExpression,
            TokenType["MINUS"]: parsePrefixExpression,
            TokenType["TRUE"]: parseBoolean,
            TokenType["FALSE"]: parseBoolean,
            TokenType["LPAREN"]: parseGroupedExpression,
            TokenType["IF"]: parseIfExpression,
            TokenType["FUNCTION"]: parseFunctionLiteral,
            TokenType["STRING"]: parseStringLiteral,
            TokenType["NULL"]: parseNullLiteral,
            TokenType["LBRACKET"]: parseArrayLiteral,
            TokenType["LBRACE"]: parseHashLiteral,
        }
    }
    
    let infixParseFns = fn (){
        {
            TokenType["PLUS"]: parseInfixExpression,
            TokenType["MINUS"]: parseInfixExpression,
            TokenType["SLASH"]: parseInfixExpression,
            TokenType["ASTERISK"]: parseInfixExpression,
            TokenType["MODULO"]: parseInfixExpression,
            TokenType["EQ"]: parseInfixExpression,
            TokenType["NOT_EQ"]: parseInfixExpression,
            TokenType["AND"]: parseInfixExpression,
            TokenType["OR"]: parseInfixExpression,
            TokenType["LT"]: parseInfixExpression,
            TokenType["LTE"]: parseInfixExpression,
            TokenType["GT"]: parseInfixExpression,
            TokenType["GTE"]: parseInfixExpression,
            TokenType["LPAREN"]: parseCallExpression,
            TokenType["LBRACKET"]: parseIndexExpression,
            TokenType["ASSIGN"]: parseAssignExpression,
        }
    }
    
    let nextToken = fn() {
        currentToken = peekToken;
        peekToken = lexer.nextToken()
    }

    let parseBoolean = fn() {
        return ast.newBoolean(currentToken, currentTokenIs(TokenType.TRUE))
    }

    let parseIdentifier = fn() {
        return ast.newIdentifier(currentToken, currentToken.literal)
    }

    let parseIntegerLiteral = fn() {
        let lit = ast.newIntegerLiteral(currentToken)
        lit["value"] = currentToken.literal
        return lit
    }

    let parseStringLiteral = fn() {
        return ast.newStringLiteral(currentToken, currentToken.literal)
    }

    let parseNullLiteral = fn() {
        return ast.newNullLiteral(currentToken, currentToken.literal)
    }

    let parseArrayLiteral = fn() {
        let array = ast.newArrayLiteral(currentToken);
        array["elements"] = parseExpressionList(TokenType.RBRACKET);
        return array;
    };

    let parseHashLiteral = fn() {
        let lit = ast.newHashLiteral(currentToken)

        while(fn(){!peekTokenIs(TokenType.RBRACE)}, fn() {
            nextToken()
            let key = parseExpression(Precedence.LOWEST)

            if (!expectPeek(TokenType.COLON)) {
                return null
            }
            nextToken()
            let value = parseExpression(Precedence.LOWEST)

            if (lit["pairs"] == null) {
                lit["pairs"] = {}
            }
            lit["pairs"][key] = value
            if (!peekTokenIs(TokenType.RBRACE) && !expectPeek(TokenType.COMMA)) {
                return null
            }
        })
        if (!expectPeek(TokenType.RBRACE)) {
            return null
        }
        return lit
    }

    let parseFunctionLiteral = fn() {
        let lit = ast.newFunctionLiteral(currentToken)

        if (!expectPeek(TokenType.LPAREN)) {
            return null
        }
        lit["parameters"] = parseFunctionParameters()

        if (!expectPeek(TokenType.LBRACE)) {
            return null
        }
        lit["body"] = parseBlockStatement()
        return lit
    }

    let parseFunctionParameters = fn() {
        let identifiers = []
        if (peekTokenIs(TokenType.RPAREN)) {
            nextToken()
            return identifiers;
        }
        nextToken()
        let ident = ast.newIdentifier(currentToken, currentToken.literal)
        identifiers = append(identifiers, ident)

        while(fn() {peekTokenIs(TokenType.COMMA)}, fn() {
            nextToken()
            nextToken()
            ident = ast.newIdentifier(currentToken, currentToken.literal)
            identifiers = append(identifiers, ident)
        })
        if (!expectPeek(TokenType.RPAREN)) {
            return null
        }
        return identifiers
    }

    let parseProgram = fn() {
        let program = ast.newProgram()
        let statements = program.statements
        while(fn(){currentToken.tokenType != "EOF"}, fn(){
            let stmt = parseStatement()
            if (stmt != null) {
                statements = append(statements, stmt)
            }
            nextToken()
        })
        program["statements"] = statements
        return program
    }

    let parseStatement = fn() {
        // TODO: implement comment, let, return statement parsing
        if (currentToken.tokenType == TokenType.COMMENT) {
            return parseCommentStatement();
        }
        if (currentToken.tokenType == TokenType.LET) {
            return parseLetStatement();
        }
        if (currentToken.tokenType == TokenType.RETURN) {
            return parseReturnStatement();
        }
        return parseExpressionStatement()
    }

    let parseCommentStatement = fn() {
        return ast.newComment(currentToken, currentToken.literal)
    }

    let parseLetStatement fn() {
        let stmt = ast.newLetStatement(currentToken);
        if (!expectPeek(TokenType.IDENT)) {
            return null
        }
        stmt["name"] = ast.newIdentifier(currentToken, currentToken.literal)
        if (!expectPeek(TokenType.ASSIGN)) {
            return null
        }
        nextToken()
        stmt["value"] = parseExpression(Precedence.LOWEST)

        if (peekTokenIs(TokenType.SEMICOLON)) {
            nextToken()
        }
        return stmt
    }

    let parseReturnStatement = fn() {
        let stmt = ast.newReturnStatement(currentToken)
        nextToken()
        stmt["returnValue"] = parseExpression(Precedence.LOWEST)

        if (peekTokenIs(TokenType.SEMICOLON)) {
            nextToken()
        }
        return stmt
    }

    let parseBlockStatement = fn() {
        let block = ast.newBlockStatement(currentToken)
        let statements = []
        nextToken()

        while (fn(){!currentTokenIs(TokenType.RBRACE) && !currentTokenIs(TokenType.EOF)}, fn() {
            let stmt = parseStatement()
            if (stmt != null) {
                statements = append(statements, stmt)
            }
            nextToken()
        })
        block["statements"] = statements
        return block
    }

    let parseExpressionStatement = fn() {
        let stmt = ast.newExpressionStatement(currentToken);
        stmt["expression"] = parseExpression(Precedence.LOWEST)

        if (peekTokenIs(TokenType.SEMICOLON)) {
            nextToken()
        }
        let exp = stmt.expression
        return stmt
    }
    
    let parseExpression = fn(precedence) {
        let prefix = prefixParseFns()[TokenType[currentToken.tokenType]]
        if (prefix == null) {
            puts("No prefix function found for token:", currentToken)
            noPrefixParseFnError(currentToken)
            return null;
        }

        let leftExp = prefix()

        while(fn(){!peekTokenIs(TokenType.SEMICOLON) && precedence < peekPrecedence()}, fn(){
            let infix = infixParseFns()[TokenType[peekToken.tokenType]]
            if (infix == null) {
                return null;
            }
            nextToken()
            leftExp = infix(leftExp)
        })
        return leftExp
        
    }

    let noPrefixParseFnError = fn(token) {
        errors = append(errors, "No prefixParse func for " + token.tokenType + " found." + token)
    }
   
    let parsePrefixExpression = fn() {
        let expression = ast.newPrefixExpression(currentToken, currentToken.literal);
        nextToken()
        expression["right"] = parseExpression(Precedence.PREFIX)
        return expression
    }

    let parseInfixExpression = fn(left) {
        let expression = ast.newInfixExpression(currentToken, currentToken.literal, left)
        let precedence = currentPrecedence()
        nextToken()
        expression["right"] = parseExpression(precedence)
        return expression
    }

    let parseGroupedExpression = fn() {
        nextToken()
        let expression = parseExpression(Precedence.LOWEST)

        if (!expectPeek(TokenType.RPAREN)) {
            return null
        }
        return expression
    }

    let parseIfExpression = fn() {
        let expression = ast.newIfExpression(currentToken)
        if (!expectPeek(TokenType.LPAREN)) {
            return null;
        }
        nextToken()
        expression["condition"] = parseExpression(Precedence.LOWEST)

        if (!expectPeek(TokenType.RPAREN)) {
            return null
        }
        if (!expectPeek(TokenType.LBRACE)) {
            return null
        }
        expression["consequence"] = parseBlockStatement()
        if (peekTokenIs(TokenType.ELSE)) {
            nextToken()
            if (!expectPeek(TokenType.LBRACE)) {
                return null
            }
            expression["alternative"] = parseBlockStatement()
        }
        return expression
        
    }

    let parseCallExpression = fn(func) {
        let exp = ast.newCallExpression(currentToken, func)
        exp["arguments"] = parseExpressionList(TokenType.RPAREN)
        return exp
    }

    let parseAssignExpression = fn(target) {
        let tok = currentToken
        nextToken()
        let right = parseExpression(Precedence.LOWEST)
        return ast.newAssignExpression(tok, target, right)
    }

    let parseIndexExpression = fn(left) {
        nextToken()
        let index = parseExpression(Precedence.LOWEST)
        let exp = ast.newIndexExpression(currentToken, left, index)

        if (!expectPeek(TokenType.RBRACKET)) {
            return null
        }
        return exp
    }

    let parseExpressionList = fn(endTokenType) {
        let expressions = []
        if (peekTokenIs(endTokenType)) {
            nextToken()
            return expressions
        }
        nextToken()
        expressions = append(expressions, parseExpression(Precedence.LOWEST))

        while(fn(){peekTokenIs(TokenType.COMMA)}, fn() {
            nextToken()
            nextToken()
            expressions = append(expressions, parseExpression(Precedence.LOWEST))
        })
        if (!expectPeek(endTokenType)) {
            return null
        }
        return expressions
    }

    let currentPrecedence = fn() {
        let p = precedences[TokenType[currentToken.tokenType]]
        if (p != null) {
            return p
        } 
        Precedence.LOWEST
    }

    let currentTokenIs = fn(tokenType) {
        currentToken.tokenType == tokenType
    }

    let peekPrecedence = fn() {
        let p = precedences[TokenType[peekToken.tokenType]]
        if (p != null) {
            return p
        } 
        Precedence.LOWEST
    }

    let expectPeek = fn(tokenType) {
        if(peekTokenIs(tokenType)) {
            nextToken()
            return true
        } else {
            peekError(tokenType)
            return false
        }
    }

    let peekError = fn(tokenType) {
        let msg = "Expected next token to be " + tokenType + ", got " + peekToken.tokenType + " instead.";
        errors = append(errors, msg)
    }

    let peekTokenIs = fn(tokenType) {
        peekToken.tokenType == tokenType
    }

    return {
        "parseProgram": parseProgram
    }

}