let newProgram = fn() {
    let statements = []

    let tokenLiteral = fn() {
        if (len(statements) > 0) {
            return statements[0].tokenLiteral()
        }
        return "";
    }

    let toString = fn() {
        return join(map(statements, fn(s) {s.toString()}),"")
    }

    return {
        "_type": "AST.PROGRAM",
        "statements": statements,
        "tokenLiteral": tokenLiteral,
        "toString": toString
    }
}

let newCommentStatement = fn(token, value) {
    let toString = fn() {
        return value
    }

    let tokenLiteral = fn() {
        token.literal
    }
    return {
        "_type": "AST.COMMENTSTATEMENT",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "value": value
    }
}

let newLetStatementent = fn(token) {
    let name = ""
    let value = null
    
    let toString = fn() {
        let out = tokenLiteral() + " " + name + " = "
        if (value != null) {
            out = out + value.toString()
        }
        out = out + ";"
        return out
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.LETSTATEMENT",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "value": value,
        "name": name
    }
}

let newIdentifier = fn(token, value) {
    let toString = fn() {
        value
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.IDENTIFIER",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "value": value,
    }
}


let newBoolean = fn(token, value) {
    let toString = fn() {
        token.literal.toString()
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.BOOLEAN",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "value": value,
    }
}

let newIntegerLiteral = fn(token) {
    let value = null;
    let toString = fn() {
        if (value == null) {
            ""
        } else {
            // TODO: confirm
            str(value)
        }
    }

    let tokenLiteral = fn() {
        token.literal
    }

    let getValue = fn() {
        int(value)
    }

    // TODO: confirm
    return {
        "_type": "AST.INTEGERLITERAL",
        "value": getValue,
        "toString": toString,
        "tokenLiteral": tokenLiteral
    }
}


let newStringLiteral = fn(token, value) {
    let toString = fn() {
        '"' + value.toString() + '"'
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.STRINGLITERAL",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "value": value,
    }
}


let newNullLiteral = fn(token, value) {
    let toString = fn() {
        "null"
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.NULLLITERAL",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "value": value,
    }
}

let newArrayLiteral = fn(token) {
    let parameters = null
    let body = null

    let toString = fn() {
        return "[" + join(map(elements, fn(e) {e.toString()}), ", ") "]"
    }

    let tokenLiteral = fn() {
        token.Literal
    }

    return {
        "_type": "AST.ARRAYLITERAL",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "elements": elements,
    }
}

let newHashLiteral = fn(token) {
    let pairs = {}

    let getPairs = fn() {
        pairs
    }

    let toString = fn() {
        let ps = map(entries(pairs), fn(pair) {
            let key = pair[0]
            let value = pair[1]
            return key.toString() + ": " + value.toString()
        }
        return "{
    " + join(ps, ",
    ") + "
}"
    }

    let tokenLiteral() {
        return token.literal
    }

    // TODO: Check for issue with pairs assignment and retrieval here
    return {
        "_type": "AST.HASHLITERAL",
        "pairs": getPairs(),
        "tokenLiteral": tokenLiteral,
        "toString": toString,
    }
}

let newFunctionLiteral = fn(token) {
    let toString = fn() {
        return "fn (" + join(map(parameters, fn(p) {p.toString()}), ", ") + ") {
    " + body.toString() + "
}"
    }

    let tokenLiteral() {
        return token.literal
    }

    return {
        "_type": "AST.HASHLITERAL",
        "parameters": parameters,
        "tokenLiteral": tokenLiteral,
        "toString": toString,
    }
}

let newIfExpression = fn(token) {
    let toString = fn() {
        let out = "if (" + condition.toString() + ") {
    " + consequence.toString() + "    
}"
        if (alternative != null) {
            out = out + "else {
    " + alternative.toString() + "
}"
        }
        return out
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.IFEXPRESSION",
        "condition": condition,
        "consequence": consequence,
        "alternative": alternative,
        "tokenLiteral": tokenLiteral,
        "toString": toString
    }
}

let newCallExpression = fn(token, func) {
    let arguments = []

    let toString = fn() {
        let a = map(arguments, fn(a) {a.toString()})
        return func.toString() + "(" + join(a, ", ") + ")"
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.CALLEXPRESSION"
        "arguments": arguments,
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "fn": func
    }
}


let newAssignExpression = fn(token, target, value) {
    let toString = fn() {
        if (value == null) {
            return target.toString() + " = null"
        }
        return target.toString() + value.toString()
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.ASSIGNEXPRESSION"
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "target": target,
        "value": value
    }
}

let newIndexExpression = fn(token, left, index) {
    let toString = fn() {
        if(index == null) {
            return left.toString() + "[null]"
        }
        return left.toString() + "[" + index.toString() + "]"
    }
    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.INDEXEXPRESSION",
        "left": left,
        "index": index,
        "tokenLiteral": tokenLiteral,
        "toString": toString,
    }
}

let newReturnStatement = fn(token) {
    let returnValue = null

    let toString = fn() {
        value
    }

    let tokenLiteral = fn() {
        token.literal
    }

    return {
        "_type": "AST.RETURNSTATEMENT",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "returnValue": returnValue,
    }
}

let newExpressionStatement = fn(token) {
    let expression = null;
    let getExpression = fn() {
        return expression
    }
    let toString = fn() {
        if (getExpression() == null) {
            ""
        } else {
            getExpression().toString()
        }
    }

    let tokenLiteral = fn() {
        token.literal
    }
    return {
        "_type": "AST.EXPRESSIONSTATEMENT",
        "token": token,
        "getExpression": getExpression,
        "expression": expression,
        "tokenLiteral": tokenLiteral,
        "toString": toString,
    }
}

let newBlockStatement = fn(token) {
    let statements = []

    let toString = fn() {
        join(map(statements, fn(stmt) {
            stmt.toString()
        }), "
    ")
    }
    let tokenLiteral = fn() {
        token.literal
    }
    return {
        "_type": "AST.BLOCKSTATEMENT",
        "toString": toString,
        "tokenLiteral": tokenLiteral,
        "statements": statements
    }
}


let newPrefixExpression = fn(token, operator) {
    let right = null;

    let toString = fn() {
        return "(" + operator + right.toString() + ")"
    }

    let tokenLiteral = fn() {
        token.literal
    }

    // TODO: confirm
    return {
        "_type": "AST.PREFIXEXPRESSION",
        "right": right,
        "toString": toString,
        "tokenLiteral": tokenLiteral
    }
}

let newInfixExpression = fn(token, operator, left) {
    let right = null;

    let toString = fn() {
        return "(" + left.toString() + operator + right.toString() + ")"
    }

    let tokenLiteral = fn() {
        token.literal
    }

    // TODO: confirm
    return {
        "_type": "AST.INFIXEXPRESSION",
        "left": left,
        "right": right,
        "operator": operator,
        "toString": toString,
        "tokenLiteral": tokenLiteral
    }
}

let instanceOf = fn(node, type) {
    return node._type == type;
}