let ast = use("./ast.üêµ");
let object = use("./object.üêµ");
let builtins = use("./builtins.üêµ")
let loops = use("../stdlib/loops.üêµ")

let instanceOf = ast.instanceOf;
let Builtins = builtins.Builtins;
let while = loops.while;

let evaluate = fn(node, env) {
    if (node == null) {
        return newError("node is null: " + node);
    }
    if (instanceOf(node, "AST.PROGRAM")) {
        return evaluateProgram(node, env)
    }
    if (instanceOf(node, "AST.EXPRESSIONSTATEMENT")) {
        return evaluate(node.expression, env)
    }
    if (instanceOf(node, "AST.BLOCKSTATEMENT")) {
        return evaluateBlockStatement(node, env)
    }
    if (instanceOf(node, "AST.RETURNSTATEMENT")) {
        return evaluateReturnStatement(node, env)
    }
    if (instanceOf(node, "AST.LETSTATEMENT")) {
        return evaluateLetStatement(node, env)
    }
    if (instanceOf(node, "AST.BOOLEAN")) {
        return object.Boolean(node.value)
    }
    if (instanceOf(node, "AST.INTEGERLITERAL")) {
        return object.Integer(node.value)
    }
    if (instanceOf(node, "AST.STRINGLITERAL")) {
        return object.String(node.value)
    }
    if (instanceOf(node, "AST.NULLLITERAL")) {
        return object.Null(node.value)
    }
    if (instanceOf(node, "AST.ARRAYLITERAL")) {
        return evaluateArrayLiteral(node, env)
    }
    if (instanceOf(node, "AST.FUNCTIONLITERAL")) {
        return evaluateFunctionLiteral(node, env)
    }
    if (instanceOf(node, "AST.IDENTIFIER")) {
        return evaluateIdentifier(node, env)
    }
    if (instanceOf(node, "AST.ASSIGNEXPRESSION")) {
        return evaluateAssignment(
            node.target,
            node.value,
            env
        )
    }
    if (instanceOf(node, "AST.PREFIXEXPRESSION")) {
        let right = evaluate(node.right, env)
        if (isError(right)) {
            return right
        }
        return evaluatePrefixExpression(node.operator, right)
    }
    if (instanceOf(node, "AST.INFIXEXPRESSION")) {
        let left = evaluate(node.left, env);
        if (isError(left)) {
            return left;
        }
        let right = evaluate(node.right, env);
        if (isError(right)) {
            return right;
        }
        return evaluateInfixExpression(node.operator, left, right, env)
    }
    puts("node before")
    puts(node)
    puts("node after")
    return newError("Asked to evaluate unknown object: " + node)
}

let evaluateProgram = fn(node, env) {
    let result = null;
    // puts("evaluate program start: result:", result)
    let i = 0
    let done = false
    let statements = node.statements
    while(fn() {i < len(statements) && !done}, fn() {
        let statement = statements[i]
        result = evaluate(statement, env);
        if (instanceOf(result, "OBJECT.RETURNVALUE")) {
            result = result.value;
            done = true;
        } else {
            if (instanceOf(result, "OBJECT.ERROR")) {
                done = true;
            }
        }
        i = i + 1;
    })
    // puts("evaluate program end: result:", result)

    return result;
}

let evaluatePrefixExpression = fn(operator, right) {
    // puts("evaluateInfixExpression called with right:", right)
    if (right == null) {
        return newError("evaluatePrefixExpression has a null right object");
    }
    if (operator == "!") {
        return evaluateBangOperatorExpression(right);
    } 
    if (operator == "-") {
        return evaluateMinusPrefixOperatorExpression(right);
    } 
    return newError("unknown operator: " + operator + right._type); 
}

let evaluateBangOperatorExpression = fn(right) {
    if (isTruthy(right)) {
        return object.Boolean(false)
    }
    return object.Boolean(true)
}

let evaluateMinusPrefixOperatorExpression = fn(right) {
    if(!instanceOf(right, "OBJECT.INTEGER")) {
        return newError("unknown operator: -" + right._type)
    }
    return object.Integer(-right.value)
}

let evaluateInfixExpression = fn(operator, left, right, env) {
    // puts("evaluateInfixExpression called with operator:", operator,  "left:", left, "right:", right)
    if (left == null || right == null) {
        return newError("Issue with infixExpression")
    }
    if (instanceOf(left, "OBJECT.INTEGER") && instanceOf(right, "OBJECT.INTEGER")) {
        return evaluateIntegerInfixExpression(operator, left, right)
    } 
    if (instanceOf(left, "OBJECT.BOOLEAN") && instanceOf(right, "OBJECT.BOOLEAN")) {
        return evaluateBooleanInfixExpression(operator, left, right)
    }
    else {
        if (left._type != right._type) {
            return newError(
                "type mismatch: " + left._type + operator + right._type
            );
        }
  }
  return newError(
    "unknown operator XXX: "+ left._type + operator + right._type
  );
}

let evaluateIntegerInfixExpression = fn(operator, left, right) {
    let l = left.value;
    let r = right.value;
    if (operator == "+") {
        return object.Integer(l + r)
    } 
    if (operator == "-") {
        return object.Integer(l - r)
    } 
    if (operator == "*") {
        return object.Integer(l * r)
    } 
    if (operator == "/") {
        return object.Integer(int(l / r))
    }
    if (operator == "<") {
        return object.Boolean(l < r)
    }
    if (operator == "<=") {
        return object.Boolean(l <= r)
    }
    if (operator == ">") {
        return object.Boolean(l > r)
    }
    if (operator == ">=") {
        return object.Boolean(l >= r)
    }
    if (operator == "==") {
        return object.Boolean(l == r)
    }
    if (operator == "!=") {
        return object.Boolean(l != r)
    }
  return newError(
    "unknown operator in evaluateIntegerInfixExpression: "+ left._type + operator + right._type
  );
}

let evaluateBooleanInfixExpression = fn(operator, left, right) {
    let l = left.value;
    let r = right.value;
    // puts("---evaluateBooleanInfixExpression with l:", l, "operator:", operator, "r:", r)
    
    if (operator == "==") {
        return object.Boolean(l == r)
    }
    if (operator == "!=") {
        return object.Boolean(l != r)
    }
    if (operator == "||") {
        return object.Boolean(l || r)
    }
    if (operator == "&&") {
        return object.Boolean(l && r)
    }
    return newError(
    "unknown operator in evaluateBooleanInfixExpression: " + left._type + operator + right._type
  );
}

let evaluateIdentifier = fn(node, env) {
    let value = env.get(node.value)
    if (value != null) {
        return value.value
    }
    let builtin = Builtins[node.value]
    if (builtin != null) {
        return builtin
    }
    return newError("identifier was not found: " + node.value)
}

let evaluateAssignment = fn(left, right, env) {
    if (instanceOf(left, "AST.IDENTIFIER")) {
        let got = env.get(left.value)
        if (got == null) {
            return newError("identifier not found: " + left.value)
        }
        let originalEnv = got.env
        let value = evaluate(right, env)
        if (isError(value)) {
            return value
        }
        return originalEnv.set(left.value, value)
    }
    if (instanceOf(left, "AST.INDEXEXPRESSION")) {
        let indexed = evaluate(left.left, env)
        if (isError(indexed)) {
            return indexed
        }
        let index = evaluate(left.index, env)
        if (isError(index)) {
            return index
        }
        if (instanceOf(indexed, "OBJECT.ARRAY") && instanceOf(index, "OBJECT.INTEGER")) {
            return evaluateArrayAssignment(indexed, index, right, env)
        }
        if (instanceOf(indexed, "OBJECT.HASH")) {
            return evaluateHashAssignment(indexed, index, right, env)
        }
        return newError("index operator not supported: " + left)
    }
    return newError("Cannot assign to something that is not an identifier or an index expression. left: " + left.toString() + " right: " + right.toString())
}

let evaluateArrayAssignment = fn(array, index, right, env) {
    let unpacked = unpackArrayIndex(array, index)
    let arrayObj = unpacked[0]
    let idx = unpacked[1]
    let max = unpacked[2]
    if (idx < 0 || idx > max) {
        return newError("index out of range")
    }
    let value = evaluate(right, env)
    if (isError(value)) {
        return value
    }
    arrayObj["elements"][idx] = value
    return value
}

let unpackArrayIndex = fn(array, index) {
    return [
        array,
        index.value,
        len(array.elements) - 1
    ]
}

let evaluateHashAssignment = fn(hash, index, right, env) {
    if (!isHashable(index)) {
        return newError("Unusable as hash key: " + index)
    }
    let hashKeyString = index.hashKey().toString()
    let value = evaluate(right, env)
    if (isError(value)) {
        return value
    }
    if (value == null) {
        return newError("RHS of hash assignment expression evaluate to host null");
    }
    let hashPair = object.HashPair(index, value)
    if (!hash.pairs) {
        hash["pairs"] = {}
    }
    hash["pairs"]["hashKeyString"] = hashPair

    return value
}

let evaluateLetStatement = fn(node, env) {
    let value = evaluate(node.value, env)
    if (isError(value)) {
        return value
    }
    env.set(node.name.value, value)
    // TODO: This doesn't return in the original, so I think it falls through
    // or just doesn't return, null seems correct. After coming back to this
    // I think object.Null() is preferable
    
    return object.Null();
}

let evaluateReturnStatement = fn(node, env) {
    let value = evaluate(node.returnValue, env)
    if (isError(value)) {
        return value
    }
    return object.ReturnValue(value)
}

let evaluateBlockStatement = fn(node, env) {
    let result = null
    let i = 0
    let done = false
    while(fn(){i < len(node.statements && !done)}, fn(){
        result = evaluate(node.statements[i], env)
        if (result != null) {
            if (instanceOf(result, "OBJECT.RETURNVALUE") || instanceOf(result, "OBJECT.ERROR")) {
                done = true
            }
        }
        i = i + 1
    })
    return result
}

let evaluateArrayLiteral = fn(node, env) {
    let elements = evaluateExpressions(node.elements, env)
    if (len(elements) == 1 && isError(elements[0])) {
        return elements[0]
    }
    return object.Array(elements)
}

let evaluateFunctionLiteral = fn(node, env) {
    let params = node.parameters;
    let body = node.body;
    return object.Function(params, body, env)
}

let isError = fn(obj) {
  if (obj != null) {
    return instanceOf(obj, "OBJECT.ERROR")
  }
  return false;
}

let isTrue = fn(obj) {
    instanceOf(obj, "OBJECT.BOOLEAN") && obj.value == true
}

let isFalse = fn(obj) {
    instanceOf(obj, "OBJECT.BOOLEAN") && obj.value == false
}

let isHashable = fn(obj) {
    // NOTE: this is && typeof obj.hashKey === function in orangutan
    // So this will overreport
    puts("isHashable with obj:", obj)
   obj != null && obj.hashKey != null
}


let newError = fn(msg) {
    return object.Error(msg);
}