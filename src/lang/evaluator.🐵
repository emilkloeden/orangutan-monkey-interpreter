let loops = use("../stdlib/loops.üêµ")
let object = use("./object.üêµ");
let ast = use("./ast.üêµ");
let instanceOf = ast.instanceOf;
let for = loops.for;

let evaluate = fn(node, env) {
    if (node == null) {
        return newError("node is null: " + node);
    }
    if (instanceOf(node, "AST.PROGRAM")) {
        return evaluateProgram(node, env)
    }
    if (instanceOf(node, "AST.EXPRESSIONSTATEMENT")) {
        return evaluate(node.expression, env)
    }
    if (instanceOf(node, "AST.BLOCKSTATEMENT")) {
        return evaluateBlockStatement(node, env)
    }
    if (instanceOf(node, "AST.RETURNSTATEMENT")) {
        return evaluateReturnStatement(node, env)
    }
    if (instanceOf(node, "AST.LETSTATEMENT")) {
        return evaluateLetStatement(node, env)
    }
    if (instanceOf(node, "AST.INTEGERLITERAL")) {
        return object.Integer(node.value)
    }
    if (instanceOf(node, "AST.STRINGLITERAL")) {
        return object.String(node.value)
    }
    if (instanceOf(node, "AST.NULLLITERAL")) {
        return object.Null(node.value)
    }
    if (instanceOf(node, "AST.ARRAYLITERAL")) {
        return evaluateArrayLiteral(node, env)
    }
    if (instanceOf(node, "AST.INFIXEXPRESSION")) {
        let left = evaluate(node.left, env);
        if (isError(left)) {
            return left;
        }
        let right = evaluate(node.right, env);
        if (isError(right)) {
            return right;
        }
        return evaluateInfixExpression(node.operator, left, right, env)
    }
    return newError("Asked to evaluate unknown object: " + node)
}

let evaluateProgram = fn(node, env) {
    let result = null;
    let i = 0
    let done = false
    while(fn() {i < len(node.statements) && !done}, fn() {
        let statement = node.statements[i]
        result = evaluate(statement, env);
        if (instanceOf(result, "OBJECT.RETURNVALUE")) {
            result = result.value;
            done = true;
        } else {
            if (instanceOf(result, "OBJECT.ERROR")) {
                done = true;
            }
        }
        i = i + 1;
    })

    return result;
}

let evaluateInfixExpression = fn(operator, left, right, env) {
    if (left == null || right == null) {
        return newError("Issue with infixExpression")
    }
    if (instanceOf(left, "OBJECT.INTEGER") && instanceOf(right, "OBJECT.INTEGER")) {
        return evaluateIntegerInfixExpression(operator, left, right)
    } else {
        if (left._type != right._type) {
            return newError(
                "type mismatch: " + left._type + operator + right._type
            );
        }
  }
  return newError(
    "unknown operator XXX: "+ left._type + operator + right._type
  );
}

let evaluateIntegerInfixExpression = fn(operator, left, right) {
    let l = left.value;
    let r = right.value;
    if (operator == "+") {
        return object.Integer(l + r)
    } if (operator == "-") {
        return object.Integer(l - r)
    } if (operator == "*") {
        return object.Integer(l * r)
    } if (operator == "/") {
        return object.Integer(int(l / r))
    }
  return newError(
    "unknown operator XXX: "+ left._type + operator + right._type
  );
}

let evaluateLetStatement = fn(node, env) {
    let value = evaluate(node.value, env)
    if (isError(value)) {
        return value
    }
    env.set(node.name.value, value)
    // TODO: This doesn't return in the original, so I think it falls through
    // or just doesn't return, null seems correct
    return null
}

let evaluateReturnStatement = fn(node, env) {
    let value = evaluate(node.returnValue, env)
    if (isError(value)) {
        return value
    }
    return object.ReturnValue(value)
}

let evaluateBlockStatement = fn(node, env) {
    let result = null
    let i = 0
    let done = false
    while(fn(){i < len(node.statements && !done)}, fn(){
        result = evaluate(node.statements[i], env)
        if (result != null) {
            if (instanceOf(result, "OBJECT.RETURNVALUE") || instanceOf(result, "OBJECT.ERROR")) {
                return result
            }
        }
    })
    return result
}

let evaluateArrayLiteral = fn(node, env) {
    let elements = evaluateExpressions(node.elements, env)
    if (len(elements) == 1 && isError(elements[0]) {
        return elements[0]
    })
    return object.Array()
}

let isError = fn(obj) {
  if (obj != null) {
    return instanceOf(obj, "OBJECT.ERROR")
  }
  return false;
}

let newError = fn(msg) {
    return object.newError(message);
}